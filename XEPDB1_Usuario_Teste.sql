-- Mostra a estrutura da tabela
DESC countries;

DESC EMPLOYEES;

DESC JOBS;

DESC LOCATIONS;


-- UTILIZANDO O SELECT MAIS BÁSICO DA TABELA

SELECT * 
FROM EMPLOYEES;

SELECT *
FROM JOBS;

SELECT *
FROM DEPARTMENTS;


-- SELECIONANDO COLUNAS ESPECÍFICAS DA TABELA

SELECT DEPARTMENT_ID, DEPARTMENT_NAME
FROM DEPARTMENTS;


SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME
FROM EMPLOYEES;


--EXPRESSÕES ARITIMETICAS

SELECT FIRST_NAME, LAST_NAME, SALARY, (SALARY + 100) * 1.15 NOVO_SALARIO
FROM EMPLOYEES;

-- VALOR NULO (AUSENCIA DE VALOR)
SELECT FIRST_NAME, LAST_NAME, JOB_ID, SALARY, COMMISSION_PCT
FROM EMPLOYEES;

--EXPRESSÕES COM VALOR NULO
SELECT FIRST_NAME, LAST_NAME, JOB_ID, COMMISSION_PCT, 20000 * COMMISSION_PCT
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NULL;

--ALIAS DE COLUNA (CABEÇALHO)

SELECT FIRST_NAME AS PRIMEIRO_NOME, LAST_NAME AS ULTIMO_NOME, SALARY AS SALÁRIO
FROM EMPLOYEES;

-- OU (A PALAVRA AS É OPCIONAL MAS O ALIAS SEMPRE VAI FICAR EM MAIÚSCULO)

SELECT FIRST_NAME PRIMEIRO_NOME, LAST_NAME ULTIMO_NOME, SALARY SALÁRIO
FROM EMPLOYEES;

-- UTILIZANDO O ALIAS COM LETRAS MINÚSUCULAS E ESPAÇO 

SELECT FIRST_NAME "Primeiro nome", LAST_NAME "Último nome", SALARY "Salário($)", COMMISSION_PCT "Percentual de Comissâo"
FROM EMPLOYEES;

--OPERADOR DE CONCATENAÇÃO

SELECT FIRST_NAME || ' ' || LAST_NAME || ', Data de admissão: ' || HIRE_DATE "Funcionário"
FROM EMPLOYEES; 

-- LINHAS DUPLICADAS

SELECT DEPARTMENT_ID
FROM EMPLOYEES;

-- RESOLVENDO ESSE PROBLEMA COM A CLÁUSULA DISTINCT

SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES;

SELECT DISTINCT LAST_NAME, FIRST_NAME
FROM EMPLOYEES;


--UTILIZANDO A CLAUSULA WHERE

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60;

--UTILIZANDO STRINGS DE CARACTERE NA CLAUSULA WHERE

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, DEPARTMENT_ID
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG';

SELECT FIRST_NAME, LAST_NAME, JOB_ID, DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE = '30/01/04';


--OPERADORES DE COMPARAÇÃO

SELECT FIRST_NAME || ' '|| LAST_NAME, SALARY, JOB_ID
FROM EMPLOYEES 
WHERE SALARY >= 10000;


SELECT FIRST_NAME, LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY BETWEEN 10000 AND 15000;

--SELECIONANDO VALORES DENTRO DE UMA LISTA UTILIZANDO O OPERADOR IN

SELECT EMPLOYEE_ID, LAST_NAME, FIRST_NAME, SALARY, MANAGER_ID, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID IN ('IT_PROG', 'FI_ACCOUNT', 'SA_REP');


--COMPARAÇÕES UTILIZANDO O OPERADOR LIKE (% - QUALQUER COISA A FRENTE OU ATRÁS), (_ UM CARACTERE QUALQUER A FRENTE OU ATRÁS)

SELECT FIRST_NAME, LAST_NAME, JOB_ID
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '%a';

SELECT FIRST_NAME, LAST_NAME, JOB_ID
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '_a%';

-- COMPARAÇÕES COM O NULL
SELECT LAST_NAME, MANAGER_ID
FROM EMPLOYEES
WHERE MANAGER_ID IS NULL;


--UTILIZANDO O OPERADOR AND

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, SALARY 
FROM EMPLOYEES
WHERE SALARY >= 5000
AND JOB_ID = 'IT_PROG';

--UTILIZANDO O OPERADOR OR 

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, SALARY 
FROM EMPLOYEES
WHERE SALARY >= 7000
OR JOB_ID = 'IT_PROG';

--UTILIZANDO O OPERADOR NOT

SELECT EMPLOYEE_ID, LAST_NAME, SALARY, MANAGER_ID, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID NOT IN ('IT_PROG', 'FI_ACCOUNT', 'SA_REP');

--REGRAS DE PRECEDENCIA
/*
1 - OPERADORES ARITIMÉTICOS
2 - OPERADOR DE CONCATENÇÃO
3 - CONDIÇÕES DE COMPARAÇÃO
4 - IS [NOT] NULL, LIKE, [NOT]IN]
5 - [NOT] BETWEEN
6 - NOT EQUAL TO
7 - NOT CONDIÇÃO LÓGICA
8 - AND CONDIÇÃO LÓGICA
9 - OR CONDIÇÃO LÓGICA 
*/


-- PODEMOS FAZER A ORDENAÇÃO COM PARENTESES
SELECT LAST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
WHERE (JOB_ID = 'SA_REP' OR JOB_ID = 'IT_PROG')
AND SALARY > 10000;

-- ORDENAÇÃO DE DADOS - ASCENDENTE
SELECT LAST_NAME, JOB_ID, DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE ASC; -- SE EU NÃO UTILIZAR O ASC, ELE JÁ ORDENA ASCENDENTEMENTE DE FORMA AUTOMÁTICA

SELECT LAST_NAME, JOB_ID, DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE ASC; 

-- ORDENAÇÃO DE DADOS - DESCENDENTE 
SELECT LAST_NAME, JOB_ID, DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE DESC;

-- SE FOR QUERER ORDENAR OS DADOS A PARTIR DE UMA EXRESSÃO MATEMÁTICA, DEVERÁ SER DA SEGUINTE FORMA
SELECT EMPLOYEE_ID, LAST_NAME, SALARY * 12 SALARIO_ANUAL
FROM EMPLOYEES
ORDER BY SALARIO_ANUAL;

-- OU

SELECT EMPLOYEE_ID, LAST_NAME, SALARY * 12
FROM EMPLOYEES
ORDER BY SALARY * 12;


-- ORDENANDO UTILIZANDO A POSIÇÃO NUMÉRICA DA COLUNA(NESSE CASO ELE ESTÁ REFERENCIANDO A COLUNA 4, OU SEJA, HIRE_DATE
SELECT LAST_NAME, JOB_ID, DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
ORDER BY 4;

-- ORDENANDO MÚLTIPLAS COLUNAS(NESSE CASO ELE PEGA A REFERENCIA DA PRIMEIRA COLUNA E SÓ DEPOIS VEM A 2°
SELECT LAST_NAME, DEPARTMENT_ID, SALARY
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID, SALARY DESC;

SELECT LAST_NAME, DEPARTMENT_ID, SALARY
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID DESC , SALARY DESC;

--UTILIZANDO VARIÁVEIS DE SUBSTITUIÇÃO - &
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = &EMPLOYEE_ID;

--UTILIZANDO VARIÁVEIS DE SUBSTITUIÇÃO -- &&
/*UTILIZE && SE VOCÊ DESEJA REUTILIZAR O VALOR DA VARIÁVEL SEM SOLICITAR UM PROMPT PARA O USUÁRIO A CADA VEZ QUE 
REFERENCIAR A VARIÁVEL*/

SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = &&EMPLOYEE_ID;


-- VARIÁVEIS DE SUBSTITUIÇÃO COM VALORES DO TIPO CHARACTER E DATE(UTILIZE ASPAS SIMPLES PARA VALORES DO TIPO CHARACTER)
SELECT LAST_NAME, DEPARTMENT_ID, JOB_ID, SALARY * 12
FROM EMPLOYEES
WHERE JOB_ID = '&JOB_ID';

-- UTILIZANDO O COMANDO DEFINE
DEFINE EMPLOYEE_ID = 101;

SELECT EMPLOYEE_ID,LAST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = &EMPLOYEE_ID;

DEFINE EMPLOYEE_ID; 

UNDEFINE EMPLOYEE_ID;



-- UTILIZANDO FUNÇÕES SINGLE ROW
-- MANIPULANDO STRINGS DE CATACTERES

SELECT LOWER('INTRODUÇÃO ORACLE 19C')
FROM DUAL; 
-- DEIXA TUDO EM MINÚSCULO

SELECT UPPER('introdução oracle 19c')
FROM DUAL; -- DEIXA TUDO EM MAIÚSCULO

SELECT INITCAP('INTRODUÇÃO ORACLE 19C')
FROM DUAL; -- DEIXA A PRIMEIRA LETRA DE CADA PALAVRA EM MAIÚSCULO E O RESTO FICA MINÚSCULO 


-- NA PRATICA
SELECT EMPLOYEE_ID, LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE LAST_NAME = 'KING'; -- NÃO TROUXE RESULTADO PORQUE A COMPARAÇÃO COM STRINGS NO ORACLE É CASE SENSITIVO

SELECT EMPLOYEE_ID, LAST_NAME "ESTÁ EM MINÚSCULO PORQUE NÃO USEI O UPPER AQUI - LAST_NAME", DEPARTMENT_ID
FROM EMPLOYEES
WHERE UPPER(LAST_NAME) = 'KING'; 
-- DEU CERTO PORQUE COM O UPPER TODOS OS LAST_NAME FICARAM MAIÚSCULOS E SERVIRAM DE COMPARAÇÃO EM SEGUIDA


-- MAIS FUNÇÕES DE MANIPULAÇÃO DE CARACTERES 
SELECT CONCAT('CURSO: ', 'INTRODUÇÃO oracle 19c')
FROM DUAL; -- CONCATENA OS STRINGS

SELECT SUBSTR('INTRODUÇÃO oracle 19C', 1, 11)
FROM DUAL; 
/* ESTA FUNCÃO PEGA APENAS PARTE DO STRING QUE EU QUISER, PRIMEIRO EU DEFINO O VALOR INICIAL{POSSO USAR O VALOR QUE EU QUISER}
, OU SEJA,NESTE CASO, A POSIÇÃO 1  E DEPOIS A POSIÇÃO FINAL QUE EU QUISER */

SELECT LENGTH('Introdução ORACLE 19c')
FROM DUAL; -- MOSTRA A QUANTIDADE DE CARACTERES 

SELECT INSTR('Introdução ORACLE 19C', 'ORACLE')
FROM DUAL; -- RETORNA A POSIÇÃO DO STRING EM QUE EU ESTOU PROCURANDO, CASO NÃO TIVER, ELE RETORNA 0

-- PRATICA

SELECT 
CONCAT('Curso:', 'Introdução ORACLE 19c'), SUBSTR('Introdução ORACLE 19c', 1,11), LENGTH('Introdução ORACLE 19c'),
INSTR('Introdução ORACLE 19c', 'ORACLE')
FROM DUAL;



-- MAIS FUNÇÕES DE MANIPULAÇÃO DE CARACTERES 
SELECT LPAD('Introdução ORACLE 19c', 30, '*')
FROM DUAL; 
/* ELE PEGA OS ARTERISCOS PRESENTES NO TERCEIRO PARÂMETRO DA FUNÇÃO E INSERE NO LADO ESQUERDO DO CONJUNTO DE CARACTERES
PRESENTES NO 1° PARÂMETRO ATÉ DAR 30 CARACTERES, QUE É O TAMANHO QUE EU DEFINI NO 2° PARÂMETRO*/


SELECT RPAD('Introdução ORACLE 19c', 30, '*')
FROM DUAL; 
/* ELE PEGA OS ARTERISCOS PRESENTES NO TERCEIRO PARÂMETRO DA FUNÇÃO E INSERE AO LADO DIREITO DO CONJUNTO DE CARACTERES
PRESENTES NO 1° PARÂMETRO ATÉ DAR 30 CARACTERES, QUE É O TAMANHO QUE EU DEFINI NO 2° PARÂMETRO*/


SELECT REPLACE('Introdução ORACLE 12c', '12c', '19c')
FROM DUAL; -- SUBSTITUI O ARGUMENTO PASSADO NO 2° PARÂMETRO PELO 3° PARÂMETRO