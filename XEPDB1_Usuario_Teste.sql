-- Mostra a estrutura da tabela
DESC countries;

DESC EMPLOYEES;

DESC JOBS;

DESC LOCATIONS;


-- UTILIZANDO O SELECT MAIS BÁSICO DA TABELA

SELECT * 
FROM EMPLOYEES;

SELECT *
FROM JOBS;

SELECT *
FROM DEPARTMENTS;


-- SELECIONANDO COLUNAS ESPECÍFICAS DA TABELA

SELECT DEPARTMENT_ID, DEPARTMENT_NAME
FROM DEPARTMENTS;


SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME
FROM EMPLOYEES;


--EXPRESSÕES ARITIMETICAS

SELECT FIRST_NAME, LAST_NAME, SALARY, (SALARY + 100) * 1.15 NOVO_SALARIO
FROM EMPLOYEES;

-- VALOR NULO (AUSENCIA DE VALOR)
SELECT FIRST_NAME, LAST_NAME, JOB_ID, SALARY, COMMISSION_PCT
FROM EMPLOYEES;

--EXPRESSÕES COM VALOR NULO
SELECT FIRST_NAME, LAST_NAME, JOB_ID, COMMISSION_PCT, 20000 * COMMISSION_PCT
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NULL;

--ALIAS DE COLUNA (CABEÇALHO)

SELECT FIRST_NAME AS PRIMEIRO_NOME, LAST_NAME AS ULTIMO_NOME, SALARY AS SALÁRIO
FROM EMPLOYEES;

-- OU (A PALAVRA AS É OPCIONAL MAS O ALIAS SEMPRE VAI FICAR EM MAIÚSCULO)

SELECT FIRST_NAME PRIMEIRO_NOME, LAST_NAME ULTIMO_NOME, SALARY SALÁRIO
FROM EMPLOYEES;

-- UTILIZANDO O ALIAS COM LETRAS MINÚSUCULAS E ESPAÇO 

SELECT FIRST_NAME "Primeiro nome", LAST_NAME "Último nome", SALARY "Salário($)", COMMISSION_PCT "Percentual de Comissâo"
FROM EMPLOYEES;

--OPERADOR DE CONCATENAÇÃO

SELECT FIRST_NAME || ' ' || LAST_NAME || ', Data de admissão: ' || HIRE_DATE "Funcionário"
FROM EMPLOYEES; 

-- LINHAS DUPLICADAS

SELECT DEPARTMENT_ID
FROM EMPLOYEES;

-- RESOLVENDO ESSE PROBLEMA COM A CLÁUSULA DISTINCT

SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES;

SELECT DISTINCT LAST_NAME, FIRST_NAME
FROM EMPLOYEES;


--UTILIZANDO A CLAUSULA WHERE

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60;

--UTILIZANDO STRINGS DE CARACTERE NA CLAUSULA WHERE

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, DEPARTMENT_ID
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG';

SELECT FIRST_NAME, LAST_NAME, JOB_ID, DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE = '30/01/04';


--OPERADORES DE COMPARAÇÃO

SELECT FIRST_NAME || ' '|| LAST_NAME, SALARY, JOB_ID
FROM EMPLOYEES 
WHERE SALARY >= 10000;


SELECT FIRST_NAME, LAST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY BETWEEN 10000 AND 15000;

--SELECIONANDO VALORES DENTRO DE UMA LISTA UTILIZANDO O OPERADOR IN

SELECT EMPLOYEE_ID, LAST_NAME, FIRST_NAME, SALARY, MANAGER_ID, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID IN ('IT_PROG', 'FI_ACCOUNT', 'SA_REP');


--COMPARAÇÕES UTILIZANDO O OPERADOR LIKE (% - QUALQUER COISA A FRENTE OU ATRÁS), (_ UM CARACTERE QUALQUER A FRENTE OU ATRÁS)

SELECT FIRST_NAME, LAST_NAME, JOB_ID
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '%a';

SELECT FIRST_NAME, LAST_NAME, JOB_ID
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '_a%';

-- COMPARAÇÕES COM O NULL
SELECT LAST_NAME, MANAGER_ID
FROM EMPLOYEES
WHERE MANAGER_ID IS NULL;


--UTILIZANDO O OPERADOR AND

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, SALARY 
FROM EMPLOYEES
WHERE SALARY >= 5000
AND JOB_ID = 'IT_PROG';

--UTILIZANDO O OPERADOR OR 

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, SALARY 
FROM EMPLOYEES
WHERE SALARY >= 7000
OR JOB_ID = 'IT_PROG';

--UTILIZANDO O OPERADOR NOT

SELECT EMPLOYEE_ID, LAST_NAME, SALARY, MANAGER_ID, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID NOT IN ('IT_PROG', 'FI_ACCOUNT', 'SA_REP');

--REGRAS DE PRECEDENCIA
/*
1 - OPERADORES ARITIMÉTICOS
2 - OPERADOR DE CONCATENÇÃO
3 - CONDIÇÕES DE COMPARAÇÃO
4 - IS [NOT] NULL, LIKE, [NOT]IN]
5 - [NOT] BETWEEN
6 - NOT EQUAL TO
7 - NOT CONDIÇÃO LÓGICA
8 - AND CONDIÇÃO LÓGICA
9 - OR CONDIÇÃO LÓGICA 
*/


-- PODEMOS FAZER A ORDENAÇÃO COM PARENTESES
SELECT LAST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
WHERE (JOB_ID = 'SA_REP' OR JOB_ID = 'IT_PROG')
AND SALARY > 10000;

-- ORDENAÇÃO DE DADOS - ASCENDENTE
SELECT LAST_NAME, JOB_ID, DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE ASC; -- SE EU NÃO UTILIZAR O ASC, ELE JÁ ORDENA ASCENDENTEMENTE DE FORMA AUTOMÁTICA

SELECT LAST_NAME, JOB_ID, DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE ASC; 

-- ORDENAÇÃO DE DADOS - DESCENDENTE 
SELECT LAST_NAME, JOB_ID, DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE DESC;

-- SE FOR QUERER ORDENAR OS DADOS A PARTIR DE UMA EXRESSÃO MATEMÁTICA, DEVERÁ SER DA SEGUINTE FORMA
SELECT EMPLOYEE_ID, LAST_NAME, SALARY * 12 SALARIO_ANUAL
FROM EMPLOYEES
ORDER BY SALARIO_ANUAL;

-- OU

SELECT EMPLOYEE_ID, LAST_NAME, SALARY * 12
FROM EMPLOYEES
ORDER BY SALARY * 12;


-- ORDENANDO UTILIZANDO A POSIÇÃO NUMÉRICA DA COLUNA(NESSE CASO ELE ESTÁ REFERENCIANDO A COLUNA 4, OU SEJA, HIRE_DATE
SELECT LAST_NAME, JOB_ID, DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
ORDER BY 4;

-- ORDENANDO MÚLTIPLAS COLUNAS(NESSE CASO ELE PEGA A REFERENCIA DA PRIMEIRA COLUNA E SÓ DEPOIS VEM A 2°
SELECT LAST_NAME, DEPARTMENT_ID, SALARY
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID, SALARY DESC;

SELECT LAST_NAME, DEPARTMENT_ID, SALARY
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID DESC , SALARY DESC;

--UTILIZANDO VARIÁVEIS DE SUBSTITUIÇÃO - &
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = &EMPLOYEE_ID;

--UTILIZANDO VARIÁVEIS DE SUBSTITUIÇÃO -- &&
/*UTILIZE && SE VOCÊ DESEJA REUTILIZAR O VALOR DA VARIÁVEL SEM SOLICITAR UM PROMPT PARA O USUÁRIO A CADA VEZ QUE 
REFERENCIAR A VARIÁVEL*/

SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = &&EMPLOYEE_ID;


-- VARIÁVEIS DE SUBSTITUIÇÃO COM VALORES DO TIPO CHARACTER E DATE(UTILIZE ASPAS SIMPLES PARA VALORES DO TIPO CHARACTER)
SELECT LAST_NAME, DEPARTMENT_ID, JOB_ID, SALARY * 12
FROM EMPLOYEES
WHERE JOB_ID = '&JOB_ID';

-- UTILIZANDO O COMANDO DEFINE
DEFINE EMPLOYEE_ID = 101;

SELECT EMPLOYEE_ID,LAST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = &EMPLOYEE_ID;

DEFINE EMPLOYEE_ID; 

UNDEFINE EMPLOYEE_ID;



-- UTILIZANDO FUNÇÕES SINGLE ROW
-- MANIPULANDO STRINGS DE CATACTERES

SELECT LOWER('INTRODUÇÃO ORACLE 19C')
FROM DUAL; 
-- DEIXA TUDO EM MINÚSCULO

SELECT UPPER('introdução oracle 19c')
FROM DUAL; -- DEIXA TUDO EM MAIÚSCULO

SELECT INITCAP('INTRODUÇÃO ORACLE 19C')
FROM DUAL; -- DEIXA A PRIMEIRA LETRA DE CADA PALAVRA EM MAIÚSCULO E O RESTO FICA MINÚSCULO 


-- NA PRATICA
SELECT EMPLOYEE_ID, LAST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE LAST_NAME = 'KING'; -- NÃO TROUXE RESULTADO PORQUE A COMPARAÇÃO COM STRINGS NO ORACLE É CASE SENSITIVO

SELECT EMPLOYEE_ID, LAST_NAME "ESTÁ EM MINÚSCULO PORQUE NÃO USEI O UPPER AQUI - LAST_NAME", DEPARTMENT_ID
FROM EMPLOYEES
WHERE UPPER(LAST_NAME) = 'KING'; 
-- DEU CERTO PORQUE COM O UPPER TODOS OS LAST_NAME FICARAM MAIÚSCULOS E SERVIRAM DE COMPARAÇÃO EM SEGUIDA


-- MAIS FUNÇÕES DE MANIPULAÇÃO DE CARACTERES 
SELECT CONCAT('CURSO: ', 'INTRODUÇÃO oracle 19c')
FROM DUAL; -- CONCATENA OS STRINGS

SELECT SUBSTR('INTRODUÇÃO oracle 19C', 1, 11)
FROM DUAL; 
/* ESTA FUNCÃO PEGA APENAS PARTE DO STRING QUE EU QUISER, PRIMEIRO EU DEFINO O VALOR INICIAL{POSSO USAR O VALOR QUE EU QUISER}
, OU SEJA,NESTE CASO, A POSIÇÃO 1  E DEPOIS A POSIÇÃO FINAL QUE EU QUISER */

SELECT LENGTH('Introdução ORACLE 19c')
FROM DUAL; -- MOSTRA A QUANTIDADE DE CARACTERES 

SELECT INSTR('Introdução ORACLE 19C', 'ORACLE')
FROM DUAL; -- RETORNA A POSIÇÃO DO STRING EM QUE EU ESTOU PROCURANDO, CASO NÃO TIVER, ELE RETORNA 0

-- PRATICA

SELECT 
CONCAT('Curso:', 'Introdução ORACLE 19c'), SUBSTR('Introdução ORACLE 19c', 1,11), LENGTH('Introdução ORACLE 19c'),
INSTR('Introdução ORACLE 19c', 'ORACLE')
FROM DUAL;



-- MAIS FUNÇÕES DE MANIPULAÇÃO DE CARACTERES 
SELECT LPAD('Introdução ORACLE 19c', 30, '*')
FROM DUAL; 
/* ELE PEGA OS ARTERISCOS PRESENTES NO TERCEIRO PARÂMETRO DA FUNÇÃO E INSERE NO LADO ESQUERDO DO CONJUNTO DE CARACTERES
PRESENTES NO 1° PARÂMETRO ATÉ DAR 30 CARACTERES, QUE É O TAMANHO QUE EU DEFINI NO 2° PARÂMETRO*/


SELECT RPAD('Introdução ORACLE 19c', 30, '*')
FROM DUAL; 
/* ELE PEGA OS ARTERISCOS PRESENTES NO TERCEIRO PARÂMETRO DA FUNÇÃO E INSERE AO LADO DIREITO DO CONJUNTO DE CARACTERES
PRESENTES NO 1° PARÂMETRO ATÉ DAR 30 CARACTERES, QUE É O TAMANHO QUE EU DEFINI NO 2° PARÂMETRO*/


SELECT REPLACE('Introdução ORACLE 12c', '12c', '19c')
FROM DUAL; -- SUBSTITUI O ARGUMENTO PASSADO NO 2° PARÂMETRO PELO 3° PARÂMETRO


SELECT TRIM(';', FROM 'nome@gmail.com;');
FROM DUAL -- REMOVE O PRIMEIRO PARÂMETRO DA FUNÇÃO AONDE QUER QUE ESTEJA ESTE ARGUMENTO NA STRING

-- PRATICA 
SELECT FIRST_NAME "Nome", LPAD(FIRST_NAME, 20, ' ') "Nome alinhado a direita",
RPAD(FIRST_NAME, 20, ' ') "Nome alinhado a esquerda"
FROM EMPLOYEES;

SELECT JOB_TITLE, REPLACE(JOB_TITLE, 'President', 'Presidente') CARGO
FROM JOBS
WHERE JOB_TITLE = 'President';

-- FUNÇÕES TIPO NUMBER

SELECT ROUND(45.965, 2)
FROM DUAL; -- ARREDONDA E DEIXA A QUANTIDADE DE CASAS DECIMAIS QUE EU INFORMAR NO 2 ARGUMENTO

SELECT ROUND(45.965, 0)
FROM DUAL; -- ARREDONDA E DEIXA A QUANTIDADE DE CASAS DECIMAIS QUE EU INFORMAR NO 2 ARGUMENTO

SELECT TRUNC(45.965, 2), TRUNC(45.965, 0) 
FROM DUAL; -- APENAS DEIXA A QUANTIDADE DE CASAS DECIMAIS QUE EU QUISER, NÃO ARREDONDA O NÚMERO


SELECT MOD(1333, 452) RESTO_DA_DIVISAO
FROM DUAL;

SELECT ABS(-9) VALOR_ABSOLUTO, SQRT(9) RAIZ_QUADRADA
FROM DUAL;

-- FUNÇÕES DO TIPO DATE/ TRABALHANDO COM DATA

SELECT SYSDATE, SYSDATE + 30, SYSDATE + 60, SYSDATE - 30
FROM DUAL;

SELECT FIRST_NAME || ' ' || LAST_NAME NOME, ROUND((SYSDATE - HIRE_DATE) / 7, 0)"Semanas de trabalho"
FROM EMPLOYEES; -- O RESULTADO DE CALCULO ENTRE DUAS DATAS É OBTIDO EM NÚMERO DE DIAS

-- OUTRAS FUNÇÕES DO TIPO DATE

SELECT FIRST_NAME || ' ' || LAST_NAME NOME, ROUND(MONTHS_BETWEEN(SYSDATE, HIRE_DATE), 2) "Meses de trabalho"
FROM EMPLOYEES;

SELECT SYSDATE, ADD_MONTHS(SYSDATE, 3), NEXT_DAY(SYSDATE, 'SEXTA FEIRA'), LAST_DAY(SYSDATE) ULTIMO_DIA_DO_MES
FROM DUAL;

SELECT SYSDATE, TO_CHAR(SYSDATE,'DD/MM/YYYY HH24:MI:SS')
FROM DUAL;


SELECT SYSDATE, TO_CHAR(TRUNC(SYSDATE),'DD/MM/YYYY HH24:MI:SS' )
FROM DUAL;

-- TO CHAR COM DATAS

SELECT last_name,TO_CHAR(hire_date, 'DD/MM/YYYY  HH24:MI:SS') DT_ADMISSÂO
FROM employees;

SELECT sysdate,TO_CHAR(sysdate, 'DD/MM/YYYY  HH24:MI:SS') DATA
FROM   dual;

SELECT last_name, TO_CHAR(hire_date, 'DD, "de" Month "de" YYYY') DT_ADMISSÂO
FROM employees;

SELECT last_name, TO_CHAR(hire_date, 'FMDD, "de" Month "de" YYYY') DT_ADMISSÂO
FROM employees; -- O FM TIRA ESPAÇOS EM BRANCO E ZEROS À ESQUERDA

-- TO_CHAR COM NUMEROS
SELECT FIRST_NAME, LAST_NAME, TO_CHAR(SALARY, 'L99G999G999D99') SALARIO
FROM EMPLOYEES; -- L = MOEDA LOCAL, G UNIDADE DE MILHAR E CENTENA, D = CASA DECIMAL

-- UTILIZANDO O TO_NUMBER
SELECT TO_NUMBER('1200,50')
FROM DUAL;


-- UTILIZANDO TO_DATE
SELECT TO_DATE('06/05/2021', 'DD/MM/YYYY') DATA
FROM DUAL;

SELECT FIRST_NAME, LAST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE = TO_DATE('17/06/2003', 'DD/MM/YYYY');
-- PARA USAR A DATA COMO COMPARAÇÃO, EU DEVO TRANSFORMAR ELA PARA O TIPO DATE PRIMEIRO, POIS ELA VEM COMO CARACTERE

-- FUNÇÕES ANINHADAS

SELECT FIRST_NAME, LAST_NAME, ROUND(MONTHS_BETWEEN(SYSDATE, HIRE_DATE), 0) NUMERO_MESES_DESDE_A_CONTRATACAO
FROM EMPLOYEES
WHERE HIRE_DATE = TO_DATE('17/06/2003', 'DD/MM/YYYY');


-- FUNÇÕES GENÉRICAS (QUE TRABALHAM COM QUAISQUER TIPOS DE DADOS):
SELECT LAST_NAME, SALARY, NVL(COMMISSION_PCT, 0), SALARY * 12 SALARIO_ANUAL,
    (SALARY * 12) + (SALARY*12*NVL(COMMISSION_PCT, 0)) REMUNERACAO_ANUAL
FROM EMPLOYEES; -- ELE TRANSFORMA TODOS COMMISSION_PCT QUE SÃO NULOS EM 0


-- UTILIZANDO A FUNÇÃO COALESCE

SELECT COALESCE(NULL, NULL, 'EXPRESSÃO 3'), COALESCE(NULL, 'EXPRESSÃO 2', 'EXPRESSÃO 3'),
       COALESCE('EXPRESSÃO 1', 'EXPRESSÃO 2', 'EXPRESSÃO 3')
FROM DUAL; --PRIMEIRO ELE ANALISA A PRIMEIRA CONDIÇÃO, SE FOR NULO ELE ANALISA O PROXIMO, SE NÃO FOR NULO ELE MOSTRA NA TELA


SELECT LAST_NAME, EMPLOYEE_ID, COMMISSION_PCT, MANAGER_ID,
       COALESCE(TO_CHAR(COMMISSION_PCT), TO_CHAR(MANAGER_ID), 'SEM PERCENTUAL DE COMISSÃO E SEM GERENTE')
FROM EMPLOYEES;

-- UTILIZANDO NVL 2
SELECT LAST_NAME, SALARY, COMMISSION_PCT, NVL2(COMMISSION_PCT, 10, 0)
FROM EMPLOYEES; -- SE COMMISION_PCT FOR NULO, ELE TRAZ O TERCEIRO ARGUMENTO (0), SE NÃO FOR NULO, ELE TRAZ O 2° ARGUEMENTO (2)

-- NULLIF

SELECT NULLIF(1000, 1000), NULLIF(1000, 2000)
FROM DUAL; -- SE OS ARGUMENTOS FOREM IGUAIS, RETORNA NULL, SE FOREM DIFERENTES, RETORNA O 1 ARGUMENTO


--        EXPRESSÕES CONDICIONAIS

-- EXPRESSÃO CASE

SELECT LAST_NAME, JOB_ID, SALARY, 
                          CASE JOB_ID 
                            WHEN 'IT_PROG'
                          THEN 1.10 * SALARY
                            WHEN 'ST_CLERK'
                          THEN 1.15 * SALARY
                            WHEN 'SA_REP'
                          THEN 1.20 * SALARY
                            ELSE SALARY
                     END "NOVO SALARIO"
FROM EMPLOYEES;                        
                   
-- DECODE

SELECT LAST_NAME, JOB_ID, SALARY, 
DECODE(JOB_ID, 'IT_PROG' , 1.10 * SALARY,
               'ST_CLERK', 1.15 * SALARY,
               'SA_REP'  , 1.20 * SALARY
                         , SALARY) "Novo Salario"
FROM EMPLOYEES;